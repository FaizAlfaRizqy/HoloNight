<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hollow Knight - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Cinzel', serif;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: url('src/game/object/background_3.png') no-repeat center center;
            background-size: cover;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .back-button {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: 'Cinzel', serif;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 50px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            display: none;
        }

        .game-over h1 {
            font-size: 48px;
            letter-spacing: 8px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
        }

        .game-over p {
            font-size: 18px;
            margin-bottom: 30px;
            letter-spacing: 2px;
        }

        .restart-btn {
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            letter-spacing: 2px;
            cursor: pointer;
            border-radius: 5px;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div class="game-ui">
        <div>Health: <span id="health">5</span>/5</div>
        <div>Score: <span id="score">0</span></div>
        <div>State: <span id="state">idle</span></div>
        <div>Enemies: <span id="enemyCount">3</span></div>
    </div>

    <div class="controls">
        <div>Controls:</div>
        <div>A/D - Move Left/Right</div>
        <div>W/Space - Jump</div>
        <div>X/Enter - Attack</div>
        <div>S - Crouch</div>
    </div>

    <a href="main.html" class="back-button">BACK TO MENU</a>

    <div class="game-over" id="gameOverScreen">
        <h1>GAME OVER</h1>
        <p>You have fallen in the depths of Hollownest</p>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="restart-btn" onclick="restartGame()">RESTART</button>
        <button class="restart-btn" onclick="window.location.href='main.html'">BACK TO MENU</button>
    </div>

    <canvas id="gameCanvas" width="1200" height="700"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        const game = {
            width: canvas.width,
            height: canvas.height,
            gravity: 0.8,
            friction: 0.8,
            isGameOver: false
        };

        // Simple platforms - MOVED UP BEFORE OTHER DEFINITIONS
        const platforms = [
            { x: 0, y: game.height - 50, width: game.width, height: 50 }, // Ground
            { x: 300, y: 500, width: 200, height: 20 },
            { x: 600, y: 400, width: 200, height: 20 },
            { x: 900, y: 300, width: 200, height: 20 }
        ];

        // Player object
        const player = {
            x: 100,
            y: 400,
            width: 64,
            height: 64,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpPower: 15,
            grounded: false,
            health: 5,
            maxHealth: 5,
            score: 0,
            invulnerable: false,
            invulnerabilityTime: 0,
            
            // Animation properties
            currentFrame: 0,
            animationSpeed: 8,
            frameCounter: 0,
            state: 'idle',
            facingRight: true,
            
            // Attack properties
            isAttacking: false,
            attackCooldown: 0,
            maxAttackFrames: 2
        };

        // Enemy spawn locations (random positions on platforms)
        const spawnLocations = [
            { x: 200, y: 618, platform: 0 },   // Ground left
            { x: 800, y: 618, platform: 0 },   // Ground right
            { x: 350, y: 468, platform: 1 },   // Platform 1
            { x: 450, y: 468, platform: 1 },   // Platform 1 right
            { x: 650, y: 368, platform: 2 },   // Platform 2
            { x: 750, y: 368, platform: 2 },   // Platform 2 right
            { x: 950, y: 268, platform: 3 },   // Platform 3
            { x: 1050, y: 268, platform: 3 }   // Platform 3 right
        ];

        // Enemy spawn system
        const enemySpawnSystem = {
            maxEnemies: 4,
            spawnQueue: [],
            spawnTimer: 0,
            spawnDelay: 600  // 10 seconds at 60fps
        };

        // Enhanced Enemy constructor
        function Enemy(x, y, platformIndex = 0) {
            const platform = platforms[platformIndex];
            return {
                x: x,
                y: y,
                width: 48,
                height: 32,
                velocityX: Math.random() > 0.5 ? 1 : -1, // Random initial direction
                speed: 0.5 + Math.random() * 1, // Random speed between 0.5-1.5
                health: 2,
                maxHealth: 2,
                alive: true,
                facingRight: true,
                platformIndex: platformIndex,
                
                // Animation properties
                currentFrame: 0,
                animationSpeed: 10 + Math.floor(Math.random() * 6), // Random animation speed
                frameCounter: 0,
                maxWalkFrames: 4,
                
                // Movement boundaries based on platform
                patrolLeft: platform.x + 20,
                patrolRight: platform.x + platform.width - 68 // 48 (enemy width) + 20 (margin)
            };
        }

        // Create enemies array (initially empty)
        let enemies = [];

        // Load idle animation sprites
        const idleSprites = [];
        for (let i = 1; i <= 5; i++) {
            const img = new Image();
            img.src = `src/game/hero/idle/idle_0${i}.png`;
            idleSprites.push(img);
        }

        // Load attack animation sprites
        const attackSprites = [];
        for (let i = 1; i <= 2; i++) {
            const img = new Image();
            img.src = `src/game/hero/attack/attack_0${i}.png`;
            attackSprites.push(img);
        }

        // Load enemy walk sprites
        const enemyWalkSprites = [];
        for (let i = 1; i <= 4; i++) {
            const img = new Image();
            img.src = `src/game/crawlid/walk/crawlid_0${i}.png`;
            enemyWalkSprites.push(img);
        }

        // Function to get random spawn location
        function getRandomSpawnLocation() {
            return spawnLocations[Math.floor(Math.random() * spawnLocations.length)];
        }

        // Function to spawn enemy
        function spawnEnemy() {
            if (enemies.filter(e => e.alive).length >= enemySpawnSystem.maxEnemies) {
                return; // Max enemies reached
            }
            
            const spawnLocation = getRandomSpawnLocation();
            const newEnemy = Enemy(spawnLocation.x, spawnLocation.y, spawnLocation.platform);
            enemies.push(newEnemy);
            
            console.log('Enemy spawned at:', spawnLocation.x, spawnLocation.y);
        }

        // Function to add enemy to spawn queue
        function queueEnemySpawn() {
            enemySpawnSystem.spawnQueue.push({
                timer: enemySpawnSystem.spawnDelay
            });
        }

        // Update spawn system
        function updateSpawnSystem() {
            // Update spawn queue timers
            for (let i = enemySpawnSystem.spawnQueue.length - 1; i >= 0; i--) {
                enemySpawnSystem.spawnQueue[i].timer--;
                
                if (enemySpawnSystem.spawnQueue[i].timer <= 0) {
                    spawnEnemy();
                    enemySpawnSystem.spawnQueue.splice(i, 1);
                }
            }
        }

        // Initialize game
        function initGame() {
            game.isGameOver = false;
            player.x = 100;
            player.y = 400;
            player.velocityX = 0;
            player.velocityY = 0;
            player.health = 5;
            player.score = 0;
            player.state = 'idle';
            player.isAttacking = false;
            player.invulnerable = false;
            player.invulnerabilityTime = 0;
            
            // Reset enemies and spawn system
            enemies = [];
            enemySpawnSystem.spawnQueue = [];
            
            // Spawn initial enemies (2-3 enemies)
            const initialEnemyCount = 2 + Math.floor(Math.random() * 2); // 2 or 3 enemies
            for (let i = 0; i < initialEnemyCount; i++) {
                spawnEnemy();
            }
            
            document.getElementById('gameOverScreen').style.display = 'none';
            console.log('Game initialized with', enemies.length, 'enemies');
        }

        // Restart game function
        function restartGame() {
            initGame();
        }

        // Input handling
        const keys = {};

        document.addEventListener('keydown', (e) => {
            if (game.isGameOver) return;
            
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;
            
            // Prevent default for space key to avoid page scrolling
            if (e.code === 'Space') {
                e.preventDefault();
            }
            
            // Attack input (X key or Enter)
            if ((e.key.toLowerCase() === 'x' || e.code === 'Enter') && !player.isAttacking && player.attackCooldown <= 0) {
                startAttack();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });

        // Start attack function
        function startAttack() {
            player.isAttacking = true;
            player.state = 'attack';
            player.currentFrame = 0;
            player.frameCounter = 0;
            player.animationSpeed = 6; // Faster attack animation
            player.attackCooldown = 30; // Cooldown after attack
        }

        // Modified checkAttackCollision to handle enemy death and respawn
        function checkAttackCollision() {
            if (!player.isAttacking) return;

            const attackRange = 70;
            const attackX = player.facingRight ? player.x + 10 : player.x - attackRange + 10;

            for (let enemy of enemies) {
                if (!enemy.alive) continue;

                // Attack collision detection
                if (enemy.x + enemy.width > attackX &&
                    enemy.x < attackX + attackRange &&
                    enemy.y + enemy.height > player.y + 10 &&
                    enemy.y < player.y + player.height - 10) {
                    
                    enemy.health--;
                    if (enemy.health <= 0) {
                        enemy.alive = false;
                        player.score += 10;
                        
                        // Queue new enemy spawn after 10 seconds
                        queueEnemySpawn();
                        
                        console.log('Enemy killed! New enemy queued for spawn.');
                    }
                    
                    // Knockback effect
                    const knockback = player.facingRight ? 25 : -25;
                    enemy.x += knockback;
                    
                    // Keep enemy in bounds of their platform
                    enemy.x = Math.max(enemy.patrolLeft, Math.min(enemy.patrolRight, enemy.x));
                    
                    break; // Only hit one enemy per attack
                }
            }
        }

        // Update enemy
        function updateEnemy(enemy) {
            if (!enemy.alive) return;

            // Animation
            enemy.frameCounter++;
            if (enemy.frameCounter >= enemy.animationSpeed) {
                enemy.frameCounter = 0;
                enemy.currentFrame = (enemy.currentFrame + 1) % enemy.maxWalkFrames;
            }

            // Movement AI - patrol back and forth on assigned platform
            enemy.x += enemy.velocityX * enemy.speed;

            // Check boundaries and reverse direction
            if (enemy.x <= enemy.patrolLeft || enemy.x >= enemy.patrolRight) {
                enemy.velocityX *= -1;
                enemy.facingRight = !enemy.facingRight;
                
                // Ensure enemy stays within bounds
                enemy.x = Math.max(enemy.patrolLeft, Math.min(enemy.patrolRight, enemy.x));
            }

            // Simple gravity for enemies
            enemy.y += 2;

            // Platform collision for enemies
            const platform = platforms[enemy.platformIndex];
            if (enemy.x + enemy.width > platform.x &&
                enemy.x < platform.x + platform.width &&
                enemy.y + enemy.height > platform.y &&
                enemy.y < platform.y + platform.height) {
                
                if (enemy.y < platform.y) {
                    enemy.y = platform.y - enemy.height;
                }
            }
        }

        // Check collision between player and enemies
        function checkEnemyCollision() {
            if (player.invulnerable) return;

            for (let enemy of enemies) {
                if (!enemy.alive) continue;

                // Simple rectangle collision with margin
                const margin = 10;
                if (player.x + margin < enemy.x + enemy.width - margin &&
                    player.x + player.width - margin > enemy.x + margin &&
                    player.y + margin < enemy.y + enemy.height - margin &&
                    player.y + player.height - margin > enemy.y + margin) {
                    
                    // Player takes damage
                    player.health--;
                    player.invulnerable = true;
                    player.invulnerabilityTime = 120; // 2 seconds of invulnerability
                    
                    // Knockback player
                    const knockbackDistance = 40;
                    if (player.x < enemy.x) {
                        player.x -= knockbackDistance;
                    } else {
                        player.x += knockbackDistance;
                    }
                    
                    // Boundary check
                    if (player.x < 0) player.x = 0;
                    if (player.x + player.width > game.width) player.x = game.width - player.width;
                    
                    // Check if player is dead
                    if (player.health <= 0) {
                        gameOver();
                    }
                    
                    break; // Only one collision per frame
                }
            }
        }

        // Game over function
        function gameOver() {
            game.isGameOver = true;
            document.getElementById('finalScore').textContent = player.score;
            document.getElementById('gameOverScreen').style.display = 'block';
        }

        // Update player animation
        function updateAnimation() {
            player.frameCounter++;
            
            if (player.frameCounter >= player.animationSpeed) {
                player.frameCounter = 0;
                
                if (player.isAttacking) {
                    player.currentFrame++;
                    
                    // Check if attack animation is complete
                    if (player.currentFrame >= player.maxAttackFrames) {
                        player.isAttacking = false;
                        player.state = 'idle';
                        player.currentFrame = 0;
                        player.animationSpeed = 8; // Back to normal speed
                    }
                } else {
                    // Normal idle animation
                    player.currentFrame = (player.currentFrame + 1) % idleSprites.length;
                }
            }
            
            // Reduce attack cooldown
            if (player.attackCooldown > 0) {
                player.attackCooldown--;
            }
            
            // Reduce invulnerability time
            if (player.invulnerabilityTime > 0) {
                player.invulnerabilityTime--;
                if (player.invulnerabilityTime <= 0) {
                    player.invulnerable = false;
                }
            }
        }

        // Update player physics and movement
        function updatePlayer() {
            if (game.isGameOver) return;

            // Update spawn system
            updateSpawnSystem();

            // Don't allow movement during attack
            if (!player.isAttacking) {
                // Horizontal movement
                if (keys['a'] || keys['arrowleft']) {
                    player.velocityX = -player.speed;
                    player.facingRight = false;
                } else if (keys['d'] || keys['arrowright']) {
                    player.velocityX = player.speed;
                    player.facingRight = true;
                } else {
                    player.velocityX *= game.friction;
                }

                // Jumping
                if ((keys['w'] || keys[' '] || keys['Space']) && player.grounded) {
                    player.velocityY = -player.jumpPower;
                    player.grounded = false;
                }
            } else {
                // Slight movement during attack
                player.velocityX *= 0.9;
            }

            // Apply gravity
            player.velocityY += game.gravity;

            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;

            // Boundary checking
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > game.width) player.x = game.width - player.width;

            // Platform collision
            player.grounded = false;
            for (let platform of platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {
                    
                    if (player.velocityY > 0 && player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.grounded = true;
                    }
                }
            }

            // Prevent falling through bottom of screen
            if (player.y + player.height > game.height) {
                player.y = game.height - player.height;
                player.velocityY = 0;
                player.grounded = true;
            }

            // Update animation
            updateAnimation();

            // Check collisions
            checkAttackCollision();
            checkEnemyCollision();

            // Update UI
            document.getElementById('health').textContent = player.health;
            document.getElementById('score').textContent = player.score;
            document.getElementById('state').textContent = player.state;
            document.getElementById('enemyCount').textContent = enemies.filter(e => e.alive).length;
        }

        // Render platforms
        function renderPlatforms() {
            ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            
            for (let platform of platforms) {
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
            }
        }

        // Render enemies
        function renderEnemies() {
            for (let enemy of enemies) {
                if (!enemy.alive) continue;

                ctx.save();
                
                // Flip sprite if facing left
                if (!enemy.facingRight) {
                    ctx.scale(-1, 1);
                    ctx.translate(-enemy.x - enemy.width, 0);
                } else {
                    ctx.translate(enemy.x, 0);
                }
                
                // Draw enemy animation frame
                if (enemyWalkSprites[enemy.currentFrame] && enemyWalkSprites[enemy.currentFrame].complete) {
                    ctx.drawImage(
                        enemyWalkSprites[enemy.currentFrame],
                        0,
                        enemy.y,
                        enemy.width,
                        enemy.height
                    );
                } else {
                    // Fallback rectangle if sprite not loaded
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
                    ctx.fillRect(0, enemy.y, enemy.width, enemy.height);
                }
                
                ctx.restore();
            }
        }

        // Render player
        function renderPlayer() {
            if (game.isGameOver) return;

            ctx.save();
            
            // Flashing effect during invulnerability
            if (player.invulnerable && Math.floor(player.invulnerabilityTime / 10) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }
            
            // Flip sprite if facing left
            if (!player.facingRight) {
                ctx.scale(-1, 1);
                ctx.translate(-player.x - player.width, 0);
            } else {
                ctx.translate(player.x, 0);
            }
            
            // Select current sprite based on state
            let currentSprites = idleSprites;
            if (player.state === 'attack') {
                currentSprites = attackSprites;
            }
            
            // Draw current animation frame
            if (currentSprites[player.currentFrame] && currentSprites[player.currentFrame].complete) {
                ctx.drawImage(
                    currentSprites[player.currentFrame],
                    0,
                    player.y,
                    player.width,
                    player.height
                );
            } else {
                // Fallback rectangle if sprite not loaded
                let color = player.state === 'attack' ? 'rgba(255, 100, 100, 0.8)' : 'rgba(255, 255, 255, 0.8)';
                ctx.fillStyle = color;
                ctx.fillRect(0, player.y, player.width, player.height);
            }
            
            ctx.restore();
        }

        // Main game loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, game.width, game.height);
            
            // Update game objects
            updatePlayer();
            
            // Update enemies
            for (let enemy of enemies) {
                updateEnemy(enemy);
            }
            
            // Render everything
            renderPlatforms();
            renderEnemies();
            renderPlayer();
            
            // Continue loop
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        function startGame() {
            console.log('Starting game...');
            initGame();
            gameLoop();
        }

        // Initialize game
        startGame();
    </script>
</body>
</html>